<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Romantic Memory - Visual Final</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body { 
            margin: 0; overflow: hidden; background-color: #050510; 
            font-family: 'Orbitron', sans-serif; user-select: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
            background: radial-gradient(circle at center, transparent 0%, #000000 120%);
        }

        /* 顶部提示 */
        #top-status {
            position: absolute; top: 20px; width: 100%; text-align: center; z-index: 20;
            color: rgba(255, 105, 180, 0.8); letter-spacing: 3px; font-size: 14px;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.5); pointer-events: none;
        }

        /* 底部按钮 */
        #controls {
            position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 20;
        }
        
        .btn {
            background: rgba(255, 105, 180, 0.1);
            border: 1px solid rgba(255, 105, 180, 0.5);
            color: #ffb7c5; padding: 12px 30px; margin: 0 15px;
            cursor: pointer; font-family: inherit; font-size: 14px; font-weight: bold;
            border-radius: 30px; transition: 0.3s;
            backdrop-filter: blur(5px); display: inline-block;
        }
        .btn:hover {
            background: rgba(255, 105, 180, 0.4); color: #fff;
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.6); transform: translateY(-2px);
        }

        /* 点击放大的灯箱 */
        #lightbox {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: none; justify-content: center; align-items: center;
            opacity: 0; transition: opacity 0.3s;
        }
        #lightbox.show { display: flex; opacity: 1; }
        #lightbox img {
            max-width: 90%; max-height: 90%;
            border: 3px solid #ff69b4; box-shadow: 0 0 50px #ff69b4;
            border-radius: 8px;
        }
        #lightbox-close {
            position: absolute; top: 30px; right: 40px; font-size: 50px; color: #fff; cursor: pointer;
        }

        /* 极简加载页 */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            z-index: 200; display: flex; justify-content: center; align-items: center;
            color: #ff69b4; font-size: 24px; letter-spacing: 5px;
        }
    </style>

    <!-- 只引入 Three.js (加载快) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loader">LOADING MEMORY...</div>

    <div id="ui-layer"></div>
    
    <div id="top-status">CLICK SCREEN TO EXPLODE / RESTORE</div>

    <div id="lightbox">
        <div id="lightbox-close">×</div>
        <img id="lb-img" src="">
    </div>

    <div id="controls">
        <label class="btn">
            ✦ Upload Photos <input type="file" id="file-input" multiple accept="image/*" style="display:none">
        </label>
        <label class="btn">
            ♫ Upload Music <input type="file" id="music-input" accept="audio/*" style="display:none">
        </label>
    </div>

    <audio id="bgm" loop></audio>
    <div id="canvas-container"></div>

    <script>
        // --- 1. 配置 ---
        const PHOTO_COUNT = 34;
        const PINK = 0xff69b4;  // 粉色
        const GOLD = 0xffb7c5;  // 玫瑰金

        let scene, camera, renderer;
        let photoGroup = new THREE.Group();
        let particles;
        let isExploded = false;
        let time = 0;
        
        // 鼠标交互
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredObj = null;
        let targetRotationX = 0;
        let targetRotationY = 0;

        // --- 2. 初始化 ---
        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            container.appendChild(renderer.domElement);

            // 灯光
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const pLight = new THREE.PointLight(PINK, 1.5, 40);
            pLight.position.set(5, 5, 10);
            scene.add(pLight);
            const gLight = new THREE.PointLight(GOLD, 1.0, 40);
            gLight.position.set(-5, -5, 10);
            scene.add(gLight);

            createObjects();
            animate();

            // 事件
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);

            // 强制移除 Loading (确保能看见画面)
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
            }, 1500);
        }

        // --- 3. 创建物体 ---
        function createObjects() {
            // 1. 粒子背景
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(800 * 3);
            for(let i=0; i<800*3; i++) pPos[i] = (Math.random()-0.5) * 60;
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({
                size: 0.2, color: PINK, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending
            });
            particles = new THREE.Points(pGeo, pMat);
            scene.add(particles);

            // 2. 照片墙
            const defTex = createColorTexture('#222');
            const frameMat = new THREE.MeshBasicMaterial({ color: GOLD });
            const glowMat = new THREE.MeshBasicMaterial({
                color: PINK, transparent: true, opacity: 0.5, 
                side: THREE.BackSide, blending: THREE.AdditiveBlending
            });

            const points = getHeartPoints(PHOTO_COUNT);

            for(let i=0; i<PHOTO_COUNT; i++) {
                const wrapper = new THREE.Group();
                
                // 辉光层
                const glow = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 2.2), glowMat.clone());
                glow.position.z = -0.02;
                wrapper.add(glow);

                // 边框层
                const border = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.9), frameMat.clone());
                border.position.z = -0.01;
                wrapper.add(border);

                // 照片层
                const photo = new THREE.Mesh(new THREE.PlaneGeometry(1.4, 1.8), new THREE.MeshBasicMaterial({map: defTex}));
                wrapper.add(photo);

                // 数据
                const pt = points[i];
                wrapper.userData = {
                    id: i,
                    heartPos: new THREE.Vector3(pt.x, pt.y, pt.z),
                    explodePos: new THREE.Vector3((Math.random()-0.5)*35, (Math.random()-0.5)*35, (Math.random()-0.5)*20),
                    explodeRot: new THREE.Euler(Math.random()*6, Math.random()*6, 0),
                    texture: defTex,
                    glow: glow,
                    border: border
                };
                
                wrapper.position.copy(wrapper.userData.heartPos);
                wrapper.lookAt(0,0,0); wrapper.rotation.z = 0;
                
                photoGroup.add(wrapper);
            }
            scene.add(photoGroup);
        }

        // 扁平心形坐标
        function getHeartPoints(count) {
            let pts = [];
            for (let i = 0; i < count; i++) {
                let t = (i / count) * Math.PI * 2;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 2; // 扁平
                x *= 1.1; 
                let s = 0.35;
                pts.push({ x: x*s, y: y*s, z: z });
            }
            return pts;
        }

        // --- 4. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // 粒子旋转
            if(particles) particles.rotation.y = time * 0.02;

            // 整体根据鼠标轻微旋转
            photoGroup.rotation.x += (targetRotationX - photoGroup.rotation.x) * 0.05;
            photoGroup.rotation.y += (targetRotationY - photoGroup.rotation.y) * 0.05;

            // 心跳
            const beat = 1 + Math.sin(time*3)*0.03;

            photoGroup.children.forEach(w => {
                let target = new THREE.Vector3();
                if(isExploded) {
                    // 爆炸
                    let fx = Math.sin(time + w.userData.id) * 0.5;
                    target.copy(w.userData.explodePos).add(new THREE.Vector3(fx,0,0));
                    
                    let r = w.userData.explodeRot;
                    w.rotation.x += (r.x - w.rotation.x) * 0.05;
                    w.rotation.y += (r.y - w.rotation.y) * 0.05;
                } else {
                    // 爱心
                    target.copy(w.userData.heartPos).multiplyScalar(beat);
                    
                    let dummy = new THREE.Object3D(); dummy.position.copy(w.position); dummy.lookAt(0,0,0);
                    w.quaternion.slerp(dummy.quaternion, 0.1);
                }
                w.position.lerp(target, 0.08);
            });

            renderer.render(scene, camera);
        }

        // --- 5. 交互逻辑 ---
        function onMouseMove(e) {
            mouse.x = (e.clientX/window.innerWidth)*2-1;
            mouse.y = -(e.clientY/window.innerHeight)*2+1;
            
            // 视差旋转
            targetRotationY = mouse.x * 0.3;
            targetRotationX = mouse.y * 0.3;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(photoGroup.children, true);
            
            if(intersects.length > 0) {
                let target = intersects[0].object;
                while(target.parent && target.parent !== photoGroup) target = target.parent;
                
                if(hoveredObj !== target) {
                    if(hoveredObj) resetObj(hoveredObj);
                    hoveredObj = target;
                    hoveredObj.scale.set(1.2, 1.2, 1.2);
                    hoveredObj.userData.glow.material.opacity = 1;
                    hoveredObj.userData.border.material.color.set(0xffffff);
                    document.body.style.cursor = 'pointer';
                }
            } else {
                if(hoveredObj) { resetObj(hoveredObj); hoveredObj = null; }
                document.body.style.cursor = 'default';
            }
        }

        function resetObj(obj) {
            obj.scale.set(1, 1, 1);
            obj.userData.glow.material.opacity = 0.5;
            obj.userData.border.material.color.set(GOLD);
        }

        function onMouseClick(e) {
            // 如果点到了照片 -> 放大
            if(hoveredObj) {
                const lb = document.getElementById('lightbox');
                const img = document.getElementById('lb-img');
                img.src = hoveredObj.userData.texture.image.src;
                lb.className = 'show';
            } 
            // 如果点到了背景 -> 切换爆炸状态
            else {
                isExploded = !isExploded;
                const status = document.getElementById('top-status');
                status.innerText = isExploded ? "STATE: EXPLODED" : "STATE: HEART";
                status.style.color = isExploded ? "#00ff00" : "rgba(255, 105, 180, 0.8)";
            }
        }

        document.getElementById('lightbox-close').onclick = () => document.getElementById('lightbox').className = '';

        // --- 6. 上传功能 ---
        function createColorTexture(col) {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d'); ctx.fillStyle=col; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }

        document.getElementById('file-input').onchange = (e) => {
            const files = Array.from(e.target.files);
            if(!files.length) return;
            e.target.parentElement.style.background = "#ff69b4";
            e.target.parentElement.style.color = "#fff";
            
            files.forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image(); img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img); tex.needsUpdate = true;
                        for(let j=0; j<PHOTO_COUNT; j++) {
                            if(j % files.length === i) {
                                photos[j].children[2].material.map = tex;
                                photos[j].children[2].material.needsUpdate = true;
                                photos[j].userData.texture = tex;
                            }
                        }
                    }
                }
                reader.readAsDataURL(file);
            });
        };

        document.getElementById('music-input').onchange = (e) => {
            const file = e.target.files[0];
            if(file) {
                const bgm = document.getElementById('bgm');
                bgm.src = URL.createObjectURL(file);
                bgm.play();
                e.target.parentElement.style.background = "#ff69b4";
                e.target.parentElement.style.color = "#fff";
            }
        };

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>