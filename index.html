<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Romantic Memory - Reliable Fix</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');

        body { 
            margin: 0; overflow: hidden; background-color: #050510; 
            font-family: 'Cinzel', serif; user-select: none;
        }

        #input-video { display: none; }

        /* UI 背景 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            background: radial-gradient(circle at center, transparent 20%, #000000 120%);
        }

        /* --- 状态监视器 (帮你确认程序没卡死) --- */
        #state-monitor {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            z-index: 60; pointer-events: none; text-align: center;
        }
        #current-state {
            font-size: 20px; font-weight: bold; letter-spacing: 3px;
            color: #ffb7c5; text-shadow: 0 0 10px #ff1493;
            transition: all 0.3s;
        }
        #gesture-val {
            font-size: 12px; color: rgba(255,255,255,0.5); margin-top: 5px; font-family: monospace;
        }

        /* 控制区 */
        #upload-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: auto; z-index: 20; width: 100%; max-width: 600px;
        }
        .btn-group { display: flex; justify-content: center; gap: 20px; margin-bottom: 12px; }
        .upload-btn {
            background: rgba(255, 105, 180, 0.15); border: 1px solid rgba(255, 105, 180, 0.6); 
            padding: 12px 30px; color: #ffc0cb; cursor: pointer; font-family: 'Cinzel', serif; 
            font-weight: bold; font-size: 0.9rem; border-radius: 50px; backdrop-filter: blur(8px);
            transition: 0.3s; display: inline-flex; align-items: center; justify-content: center;
        }
        .upload-btn:hover { 
            background: rgba(255, 105, 180, 0.4); border-color: #fff; color: #fff; transform: translateY(-3px);
        }
        #status { color: rgba(255, 255, 255, 0.4); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 2px; }
        .highlight { color: #ff69b4; font-weight: bold; }

        /* 灯箱 */
        #lightbox {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.96);
            z-index: 3000; display: none; justify-content: center; align-items: center;
        }
        #lightbox.active { display: flex; }
        #lightbox img {
            max-width: 90%; max-height: 85%; border: 3px solid #ff69b4;
            box-shadow: 0 0 80px rgba(255, 105, 180, 0.5); border-radius: 8px;
        }
        #lightbox-close {
            position: absolute; top: 30px; right: 40px; color: #fff; font-size: 40px; cursor: pointer;
        }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #020205; 
            z-index: 2000; display: flex; justify-content: center; align-items: center; 
            color: #ff69b4; font-size: 1.2rem; letter-spacing: 3px; transition: opacity 1s;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">INITIALIZING SYSTEM...</div>

    <div id="ui-layer"></div>
    
    <!-- 状态显示 -->
    <div id="state-monitor">
        <div id="current-state">STATE: HEART</div>
        <div id="gesture-val">Hand Value: 0.00</div>
    </div>

    <div id="lightbox"><div id="lightbox-close">✕</div><img id="lightbox-img" src="" alt=""></div>

    <div id="upload-container">
        <div class="btn-group">
            <label for="file-input" class="upload-btn">✦ Photos</label>
            <input type="file" id="file-input" multiple accept="image/*" style="display:none">
            <label for="music-input" class="upload-btn">♫ Music</label>
            <input type="file" id="music-input" accept="audio/*" style="display:none">
        </div>
        <div id="status"><span class="highlight">Click</span> to Zoom &nbsp;|&nbsp; <span class="highlight">Hand</span> to Interact</div>
    </div>

    <audio id="bgm" loop></audio>
    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <script>
        const PHOTO_COUNT = 34;
        const ROSE_GOLD = 0xb76e79;
        const PINK_GLOW = 0xff1493;

        let scene, camera, renderer;
        let photoGroup = new THREE.Group();
        let photos = [];
        let particles;
        
        // --- 核心状态变量 ---
        let currentState = 'HEART'; // 'HEART' or 'EXPLODE'
        let time = 0;
        let targetCameraX = 0, targetCameraY = 0;
        
        // 防抖动变量
        let lastStateChangeTime = 0;
        const STATE_COOLDOWN = 500; // 500ms 冷却时间，防止频繁切换

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15; 
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambient);
            const pLight = new THREE.PointLight(0xff69b4, 1.5, 50); pLight.position.set(5, 5, 10); scene.add(pLight);
            const gLight = new THREE.PointLight(0xffd700, 1.0, 50); gLight.position.set(-10, -5, 10); scene.add(gLight);

            createParticles(); createPhotos(); scene.add(photoGroup);

            window.addEventListener('resize', onResize);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('mousemove', onMouseMove); 
            
            // 点击背景强制重置
            window.addEventListener('click', (e) => {
                onMouseClick(e);
                if(!hoveredObj && currentState === 'EXPLODE') {
                    changeState('HEART'); // 强制收回
                }
            });

            animate();
            setTimeout(() => { document.getElementById('loader').style.display = 'none'; }, 1000);
        }

        // --- 状态切换函数 (核心修复) ---
        function changeState(newState) {
            const now = Date.now();
            if (now - lastStateChangeTime < STATE_COOLDOWN) return; // 冷却中
            if (currentState === newState) return; // 状态没变

            currentState = newState;
            lastStateChangeTime = now;

            const label = document.getElementById('current-state');
            
            if (currentState === 'EXPLODE') {
                label.innerText = "STATE: EXPLODE";
                label.style.color = "#00ff00"; // 绿字
                calculateExplosion(); // 每次切换到爆炸，重新计算随机位置
            } else {
                label.innerText = "STATE: HEART";
                label.style.color = "#ffb7c5"; // 粉字
            }
        }

        function createPhotos() {
            const frameMat = new THREE.MeshStandardMaterial({ color: ROSE_GOLD, roughness: 0.3, metalness: 0.8, emissive: PINK_GLOW, emissiveIntensity: 0.2 });
            const glowMat = new THREE.MeshBasicMaterial({ color: PINK_GLOW, transparent: true, opacity: 0.6, side: THREE.BackSide, blending: THREE.AdditiveBlending, depthWrite: false });
            const defaultTex = createColorTexture('#222');
            const planeGeo = new THREE.PlaneGeometry(1.4, 1.8);
            const borderGeo = new THREE.PlaneGeometry(1.5, 1.9);
            const glowGeo = new THREE.PlaneGeometry(1.8, 2.2);
            const points = getPerfectHeartPoints(PHOTO_COUNT);

            for (let i = 0; i < PHOTO_COUNT; i++) {
                const wrapper = new THREE.Group();
                const photoMat = new THREE.MeshBasicMaterial({ map: defaultTex });
                const photoMesh = new THREE.Mesh(planeGeo, photoMat); photoMesh.position.z = 0.05;
                const borderMesh = new THREE.Mesh(borderGeo, frameMat.clone());
                const glowMesh = new THREE.Mesh(glowGeo, glowMat.clone()); glowMesh.position.z = -0.05;

                wrapper.add(glowMesh); wrapper.add(borderMesh); wrapper.add(photoMesh);
                const pt = points[i];
                wrapper.userData = {
                    id: i, heartPos: new THREE.Vector3(pt.x, pt.y, pt.z),
                    explodePos: new THREE.Vector3(0,0,0), // 初始占位
                    explodeRot: new THREE.Euler(0,0,0),
                    texture: defaultTex, borderMesh: borderMesh, glowMesh: glowMesh      
                };
                wrapper.position.copy(wrapper.userData.heartPos); wrapper.lookAt(0, 0, 0); wrapper.rotation.z = 0; 
                photos.push(wrapper); photoGroup.add(wrapper);
            }
        }

        function getPerfectHeartPoints(count) {
            let pts = [];
            for (let i = 0; i < count; i++) {
                let t = (i / count) * Math.PI * 2;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 2; 
                x *= 1.1; let scale = 0.35;
                pts.push({ x: x * scale, y: y * scale, z: z });
            }
            return pts;
        }

        function createParticles() {
            const geo = new THREE.BufferGeometry(); const count = 800; const pos = new Float32Array(count * 3);
            for(let i=0; i<count*3; i++) pos[i] = (Math.random()-0.5)*50;
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ size: 0.2, color: 0xffb7c5, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
            particles = new THREE.Points(geo, mat); scene.add(particles);
        }

        function calculateExplosion() {
            // 每次调用都生成新的随机位置
            photos.forEach(w => {
                let theta = Math.random() * Math.PI * 2;
                let phi = Math.acos((Math.random() * 2) - 1);
                let r = 10 + Math.random() * 15;
                w.userData.explodePos.set(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                w.userData.explodeRot.set(Math.random()*6, Math.random()*6, 0);
            });
        }

        function animate() {
            requestAnimationFrame(animate); time += 0.01;
            if (particles) particles.rotation.y = time * 0.02;
            camera.position.x += (targetCameraX - camera.position.x) * 0.05;
            camera.position.y += (targetCameraY - camera.position.y) * 0.05;
            camera.lookAt(0,0,0);
            const beat = 1 + Math.sin(time*2.5)*0.03 + Math.sin(time*8)*0.01;

            photos.forEach(w => {
                let targetPos = new THREE.Vector3();
                
                if (currentState === 'EXPLODE') {
                    let floatX = Math.sin(time + w.userData.id) * 0.5;
                    targetPos.copy(w.userData.explodePos).add(new THREE.Vector3(floatX, 0, 0));
                    
                    // 爆炸时自由旋转
                    let targetRot = w.userData.explodeRot;
                    w.rotation.x += (targetRot.x - w.rotation.x) * 0.05;
                    w.rotation.y += (targetRot.y - w.rotation.y) * 0.05;
                } else {
                    // 爱心状态
                    targetPos.copy(w.userData.heartPos).multiplyScalar(beat);
                    
                    // 强制回归朝向：让心形看起来整齐
                    let dummy = new THREE.Object3D(); 
                    dummy.position.copy(w.position); 
                    dummy.lookAt(0,0,0);
                    // Slerp 插值平滑回归
                    w.quaternion.slerp(dummy.quaternion, 0.05);
                }
                w.position.lerp(targetPos, 0.08);
            });
            renderer.render(scene, camera);
        }

        // --- 交互 ---
        let hoveredObj = null;
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(photoGroup.children, true);
            if (intersects.length > 0) {
                let target = intersects[0].object;
                while(target.parent && target.parent !== photoGroup) target = target.parent;
                if (hoveredObj !== target) {
                    if (hoveredObj) resetHighlight(hoveredObj);
                    hoveredObj = target;
                    hoveredObj.scale.set(1.2, 1.2, 1.2);
                    hoveredObj.userData.borderMesh.material.emissiveIntensity = 2.0;
                    hoveredObj.userData.glowMesh.material.opacity = 1.0;
                }
            } else {
                if (hoveredObj) { resetHighlight(hoveredObj); hoveredObj = null; }
            }
        }
        function resetHighlight(obj) {
            obj.scale.set(1, 1, 1);
            obj.userData.borderMesh.material.emissiveIntensity = 0.2;
            obj.userData.glowMesh.material.opacity = 0.6;
        }
        function onMouseClick(event) {
            if (hoveredObj && hoveredObj.userData.texture) {
                const lightbox = document.getElementById('lightbox');
                const img = document.getElementById('lightbox-img');
                img.src = hoveredObj.userData.texture.image.src;
                lightbox.classList.add('active');
            }
        }
        document.getElementById('lightbox-close').addEventListener('click', () => { document.getElementById('lightbox').classList.remove('active'); });
        document.getElementById('lightbox').addEventListener('click', (e) => { if(e.target.id === 'lightbox') document.getElementById('lightbox').classList.remove('active'); });

        // 文件处理
        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = Array.from(e.target.files); if(!files.length) return;
            document.querySelector('label[for="file-input"]').innerText = "✦ Loaded ✦";
            document.querySelector('label[for="file-input"]').style.borderColor = "#fff";
            files.forEach((file, idx) => {
                if(!file.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image(); img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img); tex.needsUpdate = true; tex.colorSpace = THREE.SRGBColorSpace;
                        for(let i=0; i<PHOTO_COUNT; i++) {
                            if(i % files.length === idx) {
                                photos[i].children[2].material.map = tex;
                                photos[i].children[2].material.needsUpdate = true;
                                photos[i].userData.texture = tex;
                            }
                        }
                    }
                }
                reader.readAsDataURL(file);
            });
        });
        document.getElementById('music-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file) {
                const bgm = document.getElementById('bgm');
                bgm.src = URL.createObjectURL(file);
                bgm.play();
                document.querySelector('label[for="music-input"]').innerText = "♫ Playing...";
                document.querySelector('label[for="music-input"]').style.borderColor = "#fff";
            }
        });

        function createColorTexture(col) {
            const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx = cvs.getContext('2d'); ctx.fillStyle=col; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(cvs);
        }
        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 逻辑修复：手势 ---
        function initMediaPipe() {
            const video = document.getElementById('input-video');
            const stateLabel = document.getElementById('current-state');
            const valLabel = document.getElementById('gesture-val');
            
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    targetCameraX = (0.5 - lm[9].x) * 20;
                    targetCameraY = (0.5 - lm[9].y) * 20;
                    
                    let wrist = lm[0];
                    let dist = 0;
                    [8,12,16,20].forEach(i => {
                        dist += Math.sqrt(Math.pow(lm[i].x - wrist.x, 2) + Math.pow(lm[i].y - wrist.y, 2));
                    });
                    dist /= 4;

                    valLabel.innerText = `Value: ${dist.toFixed(2)}`;

                    // --- 触发逻辑 ---
                    // 0.40 以上：张手
                    // 0.35 以下：握拳 (0.35 已经很宽松了，只要弯一点就算)
                    if (dist > 0.40) { 
                        changeState('EXPLODE');
                    } else if (dist < 0.35) { 
                        changeState('HEART');
                    }
                } else {
                    targetCameraX = 0; targetCameraY = 0;
                    valLabel.innerText = "No Hand Detected";
                    // 自动收回
                    if(currentState === 'EXPLODE') changeState('HEART');
                }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 320, height: 240
            });
            cameraUtils.start();
        }

        initThree();
        initMediaPipe();
    </script>
</body>
</html>